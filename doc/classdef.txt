Now that we know this, we can write a macro that introduces new type
checkable handles into the programming environment.

The NEWHANDLE() macro
#define NEWHANDLE(Handle) typedef struct tag##Handle *Handle

The NEWHANDLE() declarations are almost always placed in an include file
that gets included into all source files. NEWHANDLE() is usually not
used in source files.



The only source line that may not be totally clear in Testing() is the
hRand=RandDestroy(hRand); line. By convention, all functions that
destroy an object return the NULL object, so this ends up setting hRand
to NULL.

All object destroy functions return the NULL object. 


The reasoning behind this is that you always want a handle variable to
contain a valid handle or NULL. You never want a handle variable to be
uninitialized or contain an old, previously valid, handle (



This random number generator source is contained in its own source file.
It is important to realize this. This code need not and should not be
declared along with other code, like the Testing() function, that uses
the random number generator. The implementation of an object should be
contained in a separate source file and a source file should implement,
at most, a single class object.

This implementation is in its own source file and #includes the same
include file that all other source files include. This include file
contains the NEWHANDLE(HRAND) declaration and function prototypes.


The class descriptor address is needed during run-time object
verification and it is needed when the object is created.

The key to providing object-based macros is realizing that the name of
an object's class descriptor must be based upon the variable name used
in the code and not on the data type of the object.


CLASS(hObj, Handle) {
};

The CLASS() macro is used only by source files that implement an object.
The CLASS() macro is never used in include files.

The CLASS() macro takes two arguments. The first argument is the
variable name that is used to represent instances of objects of this
class. The second argument is the handle name of the class objects. The
class descriptor is allocated and initialized based upon the variable
name and the stringizing operator (i.e., #hObj). The structure
declaration is started based upon the handle name (i.e., TYPEDEF struct
tag##Handle).

Allocating memory for a class object based upon its variable name now
becomes incredibly simple. In the case of an hRand variable name, the
number of bytes that need to be allocated is sizeof(*hObj) and the type
information address is &_CD(hObj).

Given any valid variable name that is a handle to an object, the syntax
for the run-time object verification macro is as follows:

    VERIFY(hObj);

  or

    VERIFY(hObj) {
        (block of code)
    }

VERIFY will only execute the block of code if hObj is a pointer to an
hObject.

The VERIFY() macro is designed to be used only by the source file that
implements an object, not by other source files that just use an object.

The VERIFYZ() macro is a slight variation on the VERIFY() macro. If a
NULL pointer is passed to VERIFYZ(), the optional body of code is not
executed, nor is this treated as an error. VERIFYZ() is useful in
allowing NULL pointers to be passed to an object's destroy method. 

Given a handle to an object, which is just a pointer to the object, you
should be able to obtain information about the object maintained by the
heap manager.

A model for allocating an object is NEWOBJ(hObj) and a model for freeing
an object is FREE(hObj).

An important part of the object model presented in this chapter is that
it allows us to write code that checks the validity of object handles
passed to method functions at run-time. The VERIFY() syntax  allows for
a block of code to be conditionally executed depending upon the validity
of an object handle.
